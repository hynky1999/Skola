#include "Index.h"
#include "File.h"
#include "ExprParser.h"
#include "Constants.hpp"

#include <vector>
#include <iostream>
#include <getopt.h>

int main(int argc, char *argv[])
{
	std::string create;
	bool search, include_dir, follow_sym_links;
	search = include_dir = follow_sym_links = false;
	std::string create_f, load_f, save_f, compare_f, print_o;
	/* GET OPT structure generated by vim snipet plugin*/
	int choice = -1;
	while(true)
	{
		static struct option long_options[] =
		{
			 /* Use flags like so: */
			/* Argument styles: no_argument, required_argument, optional_argument */
			{CREATE_CMD.c_str(), required_argument, 0, CREATE_CMD_SHORT},
			{LOAD_CMD.c_str(), required_argument, 0, LOAD_CMD_SHORT},
			{SAVE_CMD.c_str(), required_argument, 0, SAVE_CMD_SHORT},
			{SEARCH_CMD.c_str(), no_argument, 0, SEARCH_CMD_SHORT},
			{PRINT_CMD.c_str(), optional_argument, 0, PRINT_CMD_SHORT},
			{COMPARE_CMD.c_str(), required_argument, 0, COMPARE_CMD_SHORT},
			{INCLUDE_DIR_CMD.c_str(), no_argument, 0, INCLUDE_DIR_CMD_SHORT},
			{FOLLOW_SYM_CMD.c_str(), no_argument, 0,  FOLLOW_SYM_CMD_SHORT},
			{HELP_CMD.c_str(), no_argument, 0, HELP_CMD_SHORT},
			{0,0,0,0}
		};
		int option_index = 0;

		/* Argument parameters:
			no_argument: " "
			required_argument: ":"
			optional_argument: "::" */

		choice = getopt_long( argc, argv, OPTS_STRING.c_str(), long_options, &option_index);
		if (choice == -1)
			break;
	
		switch( choice ){
			case HELP_CMD_SHORT:
				std::cout << PRINT_HELP << std::endl;
				return 0;
				break;

			case CREATE_CMD_SHORT:
				create_f = optarg;
				break;

			case LOAD_CMD_SHORT:
				if(optarg)
					load_f = optarg;
				else
					load_f = DEFAULT_INDEX_FILENAME;
				break;	

			case SAVE_CMD_SHORT:
				std::cout << optarg << std::endl;
				save_f = optarg;
				break;

			case COMPARE_CMD_SHORT:
				compare_f = optarg;
				break;

			case SEARCH_CMD_SHORT:
				search = true;
				break;

			case PRINT_CMD_SHORT:
				if(optarg)
					print_o = optarg;
				else
					print_o = DEFAULT_PRINT;
				break;

			case INCLUDE_DIR_CMD_SHORT:
				include_dir = true;
				break;

			case FOLLOW_SYM_CMD_SHORT:
				follow_sym_links = true;
				break;

			case '?':
				/* getopt_long will have already printed an error */
				return 1;
	
			default:
				/* Not sure how to get here... */
				return EXIT_FAILURE;
		}
	}
	//Create index by either loading creating from folder
	Index i_new;
	if(!create_f.empty() && !load_f.empty()){
		std::cerr << AMBIGUOUS_ARGUMENTS_ERR << " -" << CREATE_CMD_SHORT << ",-" << LOAD_CMD_SHORT << std::endl;
		return 0;
	}

	if(!create_f.empty()){
		i_new.Create(create_f, follow_sym_links);
	}

	else if(!load_f.empty()){
		i_new.Load(load_f.c_str());
	}

	else{
		std::cerr << NO_INDEX_ERR << " using " << DEFAULT_INDEX_FILENAME << std::endl;
		i_new.Load(DEFAULT_INDEX_FILENAME.c_str());
	}

	if(!i_new.Initialized()){
		return 0;
	}

	//Search or print
	if(search){
		std::vector< std::string > args;
		while(optind < argc){
			args.push_back(argv[optind]);
			++optind;
		}
		Parser parser(args);
		std::shared_ptr< BasicExpr > expr = parser.GetExpr();
		if(expr.get() == nullptr)
			return 0;
		void (File::* func)(std::ostream &) const;
		if(print_o.empty() || print_o == DEFAULT_PRINT)
			func =  &File::Print;
		else if(print_o == "e")
			func = &File::PrintExtended;
		else
			func = nullptr;
		i_new.Search(*expr, func, include_dir);
	}
	else if(optind >= argc){
		if(!compare_f.empty()){
			Index i_old;
			if(!i_old.Load(compare_f.c_str())){
				std::cerr << INDEX_INIT_ERR << " " << compare_f << std::endl;
				return 0;
			}
			i_new.Compare(i_old);
		}
		else if(!print_o.empty()){
			std::cout << i_new;
		}
	}
	else{
		std::cerr << ARGUMENTS_MULTIPLE_ERR << std::endl;
		return 0;
	}
	// Save if wanted
	if(!save_f.empty()){
		i_new.Save(save_f.c_str());
	}

	return 0;
}
